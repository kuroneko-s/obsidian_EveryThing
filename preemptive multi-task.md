프로세스 동작들을 CPU가 선점해서 관리함.
그래서 동작하고 있는 프로세스를 CPU가 강제로 샷다운 시켜서 권한을 가져올 수 있음 (UNIX, LINUX 방식)

> non-preemptive multi-task는 CPU 입장에서 저 프로세스가 언제 끝날지 알지도 못해서 한없이 기다리는 거고, preemptive multi-task는 프로세스 입장에서 CPU가 자기를 언제 샷다운 시킬지를 모르니깐 프로세스 동작이 완전히 끝남을 보장받기가 힘들어진다.

preemtive multi-task의 동작을 보장받기 위해선 이를 관리하는 스케줄러가 중요함.
프로세스의 동작이 무한 루프가 걸려있는 상태에서 동작하고 있다고 판단하고 무제한으로 자원을 할당해주면 낭비임. 그렇다보니 스케줄러가 적당히 프로세스들을 제어하면서 자원들을 관리해야 할 필요가 있음.
잘못하다가 여러 프로세스들이 하나의 자원을 가지고 경쟁하는 문제도 일어날 수 있음. ([[race condition]], [[non thread safe]])

그리고 처리 도중에 끼어들 수 있는 개념이 등장함. ([[interrupt]])