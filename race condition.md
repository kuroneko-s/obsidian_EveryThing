여러개의 스레드 끼리 하나의 자원을 가지고 누가 먼저 가져갈건지 경쟁하는 것.
일반적으로 경쟁상태에 빠지면 [[Mutual exclusion]], [[deadlock]], [[starvation]]와 같은 제어 문제가 생김.

이런 race condition을 예방할 수 있는게 [[Semaphore]](세마포어)와 Mutex(뮤텍스, [[Mutual exclusion]]의 약어)가 있다.

race condition 발생 조건.
1. 2가지 처리가 변수를 공유
2. 적어도 하나의 처리가 그 변수를 변경할 수 있음.
3. 한쪽 처리가 한 단락 마무리 되기 전, 다른 쪽의 처리가 끼어들 가능성이 있음.

방지하려면 위 조건중 하나만이라도 해결하면 됨.

1번의 경우 처음부터 변수를 공유 못하게 만들면 됨.
기존에는 메모리를 공유해서 썼다가 UNIX가 나오면서 메모리영역을 따로 구성하는 식으로 구조가 바뀌었음.
그런데 프로세스끼리 정보를 공유해야하는 경우도 있었기에 메모리 공유가 반드시 필요했었음. 그래서 스레드가 등장함.

병행처리의 다른 모델로 Actor 모델이 있음.
일반적인 병행처리 과정에선 프로세스가 자원을 사용하면 lock을 하게 되고 locking된 자원이 있고 그 자원에 접근하려는 또 다른 프로세스가 있다면 그 프로세스는 기다려야한다. 즉, lock을 사용하여 자원에 대한 접근제어를 할 경우 비효율적으로 된다.
Actor 모델은 처리 A 내부에서 B를 요청하여 처리를하게 될 때, A의 자체 처리는 전부 끝나고 B한테 처리를 요청해야하는 부분에서 B가 A의 처리가 아닌 다른 처리를 하고있는 동안은 A가 기다리게 되고 이렇게되면 비효율적이니깐 A가 B한테 처리하고 결과 보내달라고 한 후 A는 완전히 다른 처리를 하거나 쉬게 됨. 그리고 B는 자기가 하던 처리를 끝마친다음 A가 나한테 요청했었던거를 확인하고 이를 처리함. 그리고 이 처리결과를 A한테 전달해줌. A는 자기가 다른거 하다가 B한테서 뭔가 온거를 보고 처리 수행 결과를 판단하게됨.
이게 Actor 모델.
이런 방식은 대용량의 데이터를 처리할 때 적합함. Facebook이나 Twitter에서 대량의 사용자 메시지를 처리할 때 사용됨. Erlang이나 Scala에서 이 모델을 채용하고 있음
> 그래서 트위터 코드가 Scala로 되어잇었구나.

