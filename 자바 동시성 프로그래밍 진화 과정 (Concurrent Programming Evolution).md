> [참고 블로그](https://homoefficio.github.io/2020/12/11/Java-Concurrency-Evolution/)

동시성 처리 관련 여러 방식들을 나열하고 [[Project Loom]] 코드도 일부 작성할 예정.

> [블로그의 참고 원문](https://dzone.com/articles/java-concurrency-evolution)

자바 1.1에서 가상 스레드를 지원했다가 폐기되고 OS 네이티브 스레드를 지원했다가 프로그래밍 스레드 흐름이 가상 스레드 흐름으로 넘어가면서 [[Project Loom]]이 도입되면서 전환된거지.

### 자바 스레드
- JVM 스레드 === OS 스레드. OS 스레드를 커스텀한게 JVM 스레드.
- OS 스레드는 겁나 느림. OS는 JVM 내부에 대해 개입 안함.
- 스레드간 데이터 교신은 커널을 거쳐야해서 자원이 많이 소모됨. (느림)
- OS의 [[continuation]] 구현체는 자바 콜 스택 뿐만 아니라 네이티브 콜 스택도 포함하며, 자원을 많이 소모한다.
- OS 스레드 갯수 <= CPU 코어 갯수
- 스레드에 사용되는 스택 메모리는 OS에 의해 힙 외의 영역에 마련된다.
![[image1.png]]

### 태스크
스레드에서 동작하는 단위.

### 네이티브 멀티 스레딩
- CPU코어나 메모리의 자원을 효율적으로 사용할 수 있을 것인가.
- 세밀한 스레드를 조정 및 관리할 수 있을 것인가.
- 제어 흐름과 컨텍스트 유실 (스택 트레이스가 스레드에 바운드 되므로 (한정되므로) 문제가 있는 스택 트레이스를 볼 수 없다.)
- 실행 동기화
- 디버깅과 테스트 어렵지..

### ExcutorService
스레트 풀을 통해서 스레스 생성 부담을 줄여줌.
태스트는 submit 되서 큐에 들어가고, 작업 가능한 스레드가 큐에서 태스크를 가져다가 실행함.
![[image2.jpg]]

- 아직도 JVM 스레드 갯수는 OS 스레드 갯수에 영향을 받고 있음
- 스레드 풀에서 스레드를 하나 가져가면 동작하지 않아도 다른곳에서 가져갈 수 없음. 
- 결과 값이 Feture가 반환되지만 조립은 할 수 없다 ? (get()을 써서 대기해야함. 각각의 스레드가 get()을 쓰면 각 스레드가 끝날때까지 기다려주는데 이것들을 하나로 취합하기 애매함 ?)

지금 이게 백업이 되고있는건가 ??? 

이게 자동으로 올라가고있는건지 확인이 됬으면 하는데
안되는거같네.