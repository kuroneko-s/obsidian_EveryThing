과거에는 I/O 작업이 이루어지면 CPU가 해당 동작에 대해서 제어를 못했었음.
I/O 작업이 완료되기를 무한정 기다릴 수 밖에 없었다.
이렇게 동작 시키지 말고 한번에 여러개를 동작하게 되면 얼마나 좋을까 ? => 스레드 등장.
스레드가 등장하니깐 동작을 여러곳에서 하니깐 이거에 대한 스케줄링의 역할을 하는 스케줄러의 성능 및 동작 방식이 중요하게 됨.
그래서 Lock이나 Fiber가 등장해서 스케줄링을 도와줌. (접근 방지하게 해주는 기술들)

기본적으로 병행 동작에는 두가지 방법이 있음.
- preemptive multi-task(선점형 멀티태스크)
- non-preemptive multi-task(비선점형 멀티태스크)

### non-preemptive multi-task
하나의 동작을 처리하고 있을때 CPU를 독점하고 있고, CPU는 해당 동작에 대해서 관여를 하지 않는다.
즉, 수행중인 프로세스가 자신의 동작을 끝맞쳤을때 스스로 동작을 멈출때 제어가 다른 곳으로 넘어가진다.(window 3.1, maxOS 9)
### preemptive multi-task
프로세스 동작들을 CPU가 선점해서 관리함.
그래서 동작하고 있는 프로세스를 CPU가 강제로 샷다운 시켜서 권한을 가져올 수 있음 (UNIX, LINUX 방식)

> non-preemptive multi-task는 CPU 입장에서 저 프로세스가 언제 끝날지 알지도 못해서 한없이 기다리는 거고, preemptive multi-task는 프로세스 입장에서 CPU가 자기를 언제 샷다운 시킬지를 모르니깐 프로세스 동작이 완전히 끝남을 보장받기가 힘들어진다.

preemtive multi-task의 동작을 보장받기 위해선 이를 관리하는 스케줄러가 중요함.
프로세스의 동작이 무한 루프가 걸려있는 상태에서 동작하고 있다고 판단하고 무제한으로 자원을 할당해주면 낭비임. 그렇다보니 스케줄러가 적당히 프로세스들을 제어하면서 자원들을 관리해야 할 필요가 있음.
잘못하다가 여러 프로세스들이 하나의 자원을 가지고 경쟁하는 문제도 일어날 수 있음. ([[race condition]], non thread safe)

