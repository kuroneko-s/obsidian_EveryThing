> [참고 블로그](https://junghyungil.tistory.com/103)

![[image3.png]]

### ForkJoinPool 인터페이스
![[image4.png]]

#### RecursiveAction
리턴 값이 없는 Task.
compute 구현 메서드가 실행됨.

#### RecursiveTask
리턴 값이 있는 Task.
join()을 사용해서 리턴값을 받을떄까지 블럭됨.
리턴 타입은 Feture 타입.

##### Feture
리턴 값.

일반 스레드 작업인 ExecutorService랑 일반적으로 비교를 했을 경우, 골고루 잘 분배되서 작성을 하게 될 경우에는 Executor 인터페이스가 더 빠르고 좋다. 그런데, 잘 분배되지 않고 일부 스레드에 부하가 심하게 걸리는 작업을 하게 될 경우 Fork&Join 라이브러리가 더 빠르게 동작한다.
+ Executor에서 메모리 초과 에러 날 경우도 이 라이브러리는 방지해줄 수 있음. (일부 스레드에 부하가 심하게 걸리는 작업을 하게될 경우 더 빠르다는 이점을 가지는것과 비슷한 맥락. 일부 스레드에서 메모리 초과나버리기전에 태스크를 가져와서 작업을 하게 되니깐 에러가 날 확률이 적어짐. 그만큼 안정성이 좋다는거지...)


그런데 Fork&Join 라이브러리를 사용하게 될 경우 구현해야하는 객체도 늘어나서 상황을 봐가면서 작성해야한다/